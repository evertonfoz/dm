# MÓDULO 5: IMPLEMENTAÇÃO PRÁTICA - DASHBOARD RESPONSIVO COMPLETO

## **SLIDE 13: Planejamento do Dashboard - Da Concepção à Implementação**

Antes de escrevermos uma única linha de código, precisamos entender profundamente o que estamos construindo e por quê. Um dashboard responsivo bem-sucedido não é apenas código que funciona em diferentes tamanhos de tela, mas sim uma experiência cuidadosamente planejada que se adapta às necessidades e contextos de uso de cada tipo de dispositivo. Vamos abordar este planejamento como faríamos em um ambiente profissional real.

Imagine que você foi contratado para desenvolver um dashboard de vendas para uma empresa. Este dashboard precisa permitir que vendedores em campo (usando smartphones) consultem rapidamente suas métricas individuais, que gerentes em tablets analisem o desempenho de suas equipes durante reuniões, e que diretores em desktops façam análises profundas com múltiplos gráficos e filtros complexos. Cada contexto de uso tem necessidades diferentes, e nosso design precisa responder apropriadamente a cada um.

**Análise de Requisitos por Dispositivo:**

Em dispositivos mobile, onde a largura é extremamente limitada e o usuário provavelmente está em movimento, precisamos priorizar informações críticas e ações rápidas. O vendedor em campo quer ver rapidamente suas vendas do dia, sua meta e quantas vendas faltam para atingi-la. Ele não tem tempo nem espaço de tela para gráficos complexos ou múltiplas visualizações simultâneas. Portanto, nossa implementação mobile deve ser vertical, com cards empilhados que mostram uma métrica por vez, permitindo scroll rápido para acessar informações adicionais.

Em tablets, o cenário muda significativamente. O gerente está provavelmente em uma reunião ou revisão de desempenho, tem mais tempo para análise e precisa comparar métricas de diferentes membros da equipe. Aqui podemos introduzir um layout de duas colunas, onde a coluna principal mostra gráficos e a lateral mostra listas de vendedores ou filtros. O usuário pode tocar em um vendedor na lista e ver seus detalhes na área principal. Esta interação aproveita o espaço adicional sem sobrecarregar a interface.

Em desktops, finalmente temos espaço abundante e um usuário que tipicamente passa mais tempo realizando análises profundas. O diretor quer ver múltiplos gráficos simultaneamente, comparar períodos, filtrar por região e produto, talvez até exportar relatórios. Nossa implementação desktop pode ter três colunas: uma barra lateral esquerda com filtros sempre visível, uma área central com gráficos principais em grid, e uma coluna direita com métricas de resumo e rankings. Tudo visível simultaneamente, eliminando a necessidade de navegação constante.

**Componentes do Dashboard:**

Vamos estruturar nosso dashboard em componentes modulares que podem ser reorganizados conforme o dispositivo. Precisamos de um componente de métrica (MetricCard) que mostra um valor numérico com sua variação, um componente de gráfico (ChartCard) que encapsula diferentes tipos de visualização, um componente de lista (TopSellersList) que mostra rankings, e um componente de filtros (FilterPanel) que permite refinar os dados exibidos.

A beleza desta abordagem modular é que os mesmos componentes são reutilizados em todos os layouts, apenas sua disposição espacial e algumas propriedades visuais mudam. O MetricCard é o mesmo em mobile e desktop, mas em mobile ele ocupa a largura total da tela, enquanto em desktop ele pode estar em um grid com outros cards.

**Esquema Visual da Estrutura:**

```dart
// Estrutura conceitual do dashboard (ainda não é código executável)

DashboardScreen
├─ MobileDashboard
│  └─ ListView vertical
│     ├─ MetricCard (Vendas Hoje)
│     ├─ MetricCard (Meta do Mês)
│     ├─ ChartCard (Gráfico Simples)
│     └─ TopSellersList (Top 3)
│
├─ TabletDashboard
│  └─ Row com 2 colunas
│     ├─ Column esquerda (30%)
│     │  ├─ FilterPanel
│     │  └─ TopSellersList
│     └─ Column direita (70%)
│        ├─ Grid 2x2 de MetricCards
│        └─ ChartCard expandido
│
└─ DesktopDashboard
   └─ Row com 3 colunas
      ├─ Sidebar esquerda (20%)
      │  └─ FilterPanel expandido
      ├─ Área central (60%)
      │  ├─ Row de MetricCards
      │  └─ Grid 2x2 de ChartCards
      └─ Sidebar direita (20%)
         ├─ MetricCard resumo
         └─ TopSellersList completa
```

Este esquema nos dá um mapa claro do que precisamos construir. Cada componente tem uma responsabilidade específica e clara, e podemos desenvolvê-los de forma independente antes de montá-los nos diferentes layouts. Esta é a essência do desenvolvimento modular e responsivo profissional.

**Definindo o Contrato de Dados:**

Antes de implementar os componentes visuais, precisamos definir as estruturas de dados que eles consumirão. Isto garante que todos os componentes falem a mesma língua e facilita enormemente o desenvolvimento e manutenção.

```dart
// lib/models/dashboard_data.dart

/// Representa uma métrica individual do dashboard
class MetricData {
  final String title;           // Nome da métrica (ex: "Vendas Hoje")
  final double value;           // Valor atual da métrica
  final double? previousValue;  // Valor anterior para cálculo de variação
  final String unit;            // Unidade (ex: "R$", "unidades")
  final IconData icon;          // Ícone representativo
  
  MetricData({
    required this.title,
    required this.value,
    this.previousValue,
    this.unit = '',
    required this.icon,
  });
  
  /// Calcula a variação percentual em relação ao valor anterior
  double get percentChange {
    if (previousValue == null || previousValue == 0) return 0.0;
    return ((value - previousValue!) / previousValue!) * 100;
  }
  
  /// Retorna true se a métrica melhorou
  bool get isPositive => percentChange >= 0;
}

/// Representa dados para um gráfico
class ChartData {
  final String label;    // Label do ponto (ex: "Jan", "Segunda")
  final double value;    // Valor numérico
  
  ChartData(this.label, this.value);
}

/// Representa um vendedor no ranking
class SellerData {
  final String name;
  final double sales;
  final int position;
  
  SellerData({
    required this.name,
    required this.sales,
    required this.position,
  });
}
```

Estas classes de modelo são simples mas poderosas. Elas encapsulam toda a lógica de negócio relacionada aos dados (como o cálculo de variação percentual) e fornecem uma interface limpa para os componentes visuais consumirem. Note que não há nenhuma lógica de UI nestes modelos, eles são puramente sobre dados e suas transformações, seguindo o princípio de separação de responsabilidades.

---

## **SLIDE 14: Implementando Componentes Reutilizáveis**

Agora que temos nossa estrutura de dados definida, podemos começar a implementar os componentes visuais que serão a base do nosso dashboard. Cada componente será completamente independente e reutilizável, recebendo seus dados através de parâmetros e se adaptando automaticamente ao espaço disponível.

**Componente MetricCard - Exibindo Métricas com Elegância:**

O MetricCard é provavelmente o componente mais usado em dashboards. Ele precisa mostrar um valor numérico de forma visualmente atraente, incluindo sua variação em relação a um período anterior. Vamos criar uma implementação que seja ao mesmo tempo bonita e informativa.

```dart
// lib/widgets/dashboard/metric_card.dart

import 'package:flutter/material.dart';
import '../../models/dashboard_data.dart';
import '../../core/responsive/responsive_values.dart';

/// Card que exibe uma métrica individual com seu valor e variação.
/// 
/// Este componente é completamente responsivo, adaptando tamanhos de fonte
/// e espaçamentos baseado no dispositivo onde está sendo renderizado.
class MetricCard extends StatelessWidget {
  final MetricData data;
  
  const MetricCard({
    Key? key,
    required this.data,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      child: Padding(
        // Padding adaptativo baseado no dispositivo
        padding: EdgeInsets.all(
          ResponsiveValues.getHorizontalPadding(context),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Linha superior: ícone e título
            Row(
              children: [
                Icon(
                  data.icon,
                  size: 24,
                  color: Theme.of(context).primaryColor,
                ),
                SizedBox(width: ResponsiveValues.getElementSpacing(context)),
                Expanded(
                  child: Text(
                    data.title,
                    style: TextStyle(
                      fontSize: ResponsiveValues.getBodyFontSize(context),
                      color: Colors.grey[600],
                      fontWeight: FontWeight.w500,
                    ),
                  ),
                ),
              ],
            ),
            
            SizedBox(height: ResponsiveValues.getElementSpacing(context)),
            
            // Valor principal da métrica
            Text(
              '${data.unit}${_formatNumber(data.value)}',
              style: TextStyle(
                fontSize: ResponsiveValues.getTitleFontSize(context),
                fontWeight: FontWeight.bold,
                color: Colors.black87,
              ),
            ),
            
            // Indicador de variação (se houver valor anterior)
            if (data.previousValue != null) ...[
              SizedBox(height: ResponsiveValues.getElementSpacing(context) / 2),
              _buildChangeIndicator(context),
            ],
          ],
        ),
      ),
    );
  }
  
  /// Constrói o indicador visual de variação (positiva ou negativa)
  Widget _buildChangeIndicator(BuildContext context) {
    final isPositive = data.isPositive;
    final percentChange = data.percentChange.abs();
    
    return Row(
      children: [
        Icon(
          isPositive ? Icons.trending_up : Icons.trending_down,
          size: 16,
          color: isPositive ? Colors.green : Colors.red,
        ),
        SizedBox(width: 4),
        Text(
          '${percentChange.toStringAsFixed(1)}%',
          style: TextStyle(
            fontSize: ResponsiveValues.getBodyFontSize(context) * 0.9,
            color: isPositive ? Colors.green : Colors.red,
            fontWeight: FontWeight.w600,
          ),
        ),
        SizedBox(width: 4),
        Text(
          'vs período anterior',
          style: TextStyle(
            fontSize: ResponsiveValues.getBodyFontSize(context) * 0.85,
            color: Colors.grey[500],
          ),
        ),
      ],
    );
  }
  
  /// Formata números grandes de forma legível
  /// Exemplo: 15000 -> "15.000", 1500000 -> "1.500.000"
  String _formatNumber(double number) {
    if (number >= 1000000) {
      return '${(number / 1000000).toStringAsFixed(1)}M';
    } else if (number >= 1000) {
      return '${(number / 1000).toStringAsFixed(1)}K';
    }
    return number.toStringAsFixed(0);
  }
}
```

Este componente demonstra vários princípios importantes de design responsivo. Primeiro, ele usa ResponsiveValues consistentemente para todos os tamanhos e espaçamentos, garantindo que se adapte apropriadamente a diferentes dispositivos. Segundo, ele encapsula toda a lógica de formatação e apresentação internamente, então o código que o usa não precisa se preocupar com esses detalhes. Terceiro, ele usa o modelo MetricData que definimos anteriormente, criando uma separação clara entre dados e apresentação.

**Componente ChartCard - Visualização de Dados:**

Gráficos são essenciais em dashboards, mas podem ser complexos de implementar do zero. Vamos criar um wrapper que usa a biblioteca fl_chart (uma biblioteca popular para gráficos no Flutter) mas abstrai sua complexidade atrás de uma interface simples.

```dart
// lib/widgets/dashboard/chart_card.dart

import 'package:flutter/material.dart';
import 'package:fl_chart/fl_chart.dart';
import '../../models/dashboard_data.dart';
import '../../core/responsive/responsive_values.dart';

/// Card que exibe um gráfico de barras baseado em dados fornecidos.
/// 
/// Exemplo de uso:
/// ```dart
/// ChartCard(
///   title: 'Vendas por Dia',
///   data: [
///     ChartData('Seg', 120),
///     ChartData('Ter', 150),
///     // ...
///   ],
/// )
/// ```
class ChartCard extends StatelessWidget {
  final String title;
  final List<ChartData> data;
  final Color? barColor;
  
  const ChartCard({
    Key? key,
    required this.title,
    required this.data,
    this.barColor,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 2,
      child: Padding(
        padding: EdgeInsets.all(
          ResponsiveValues.getHorizontalPadding(context),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Título do gráfico
            Text(
              title,
              style: TextStyle(
                fontSize: ResponsiveValues.getSubtitleFontSize(context),
                fontWeight: FontWeight.bold,
              ),
            ),
            
            SizedBox(height: ResponsiveValues.getSectionSpacing(context)),
            
            // Área do gráfico expandida
            Expanded(
              child: _buildChart(context),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildChart(BuildContext context) {
    // Se não houver dados, mostra mensagem
    if (data.isEmpty) {
      return Center(
        child: Text(
          'Sem dados disponíveis',
          style: TextStyle(color: Colors.grey[400]),
        ),
      );
    }
    
    return BarChart(
      BarChartData(
        alignment: BarChartAlignment.spaceAround,
        maxY: _getMaxValue() * 1.2, // 20% acima do valor máximo para espaço
        barTouchData: BarTouchData(
          enabled: true,
          touchTooltipData: BarTouchTooltipData(
            tooltipBgColor: Colors.black87,
            getTooltipItem: (group, groupIndex, rod, rodIndex) {
              return BarTooltipItem(
                '${data[groupIndex].label}\n${rod.toY.toStringAsFixed(0)}',
                const TextStyle(color: Colors.white),
              );
            },
          ),
        ),
        titlesData: FlTitlesData(
          show: true,
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              getTitlesWidget: (value, meta) {
                // Exibe labels do eixo X
                if (value.toInt() >= 0 && value.toInt() < data.length) {
                  return Padding(
                    padding: const EdgeInsets.only(top: 8.0),
                    child: Text(
                      data[value.toInt()].label,
                      style: TextStyle(
                        fontSize: ResponsiveValues.getBodyFontSize(context) * 0.8,
                      ),
                    ),
                  );
                }
                return const Text('');
              },
            ),
          ),
          leftTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              reservedSize: 40,
              getTitlesWidget: (value, meta) {
                return Text(
                  value.toInt().toString(),
                  style: TextStyle(
                    fontSize: ResponsiveValues.getBodyFontSize(context) * 0.8,
                  ),
                );
              },
            ),
          ),
          topTitles: AxisTitles(sideTitles: SideTitles(showTitles: false)),
          rightTitles: AxisTitles(sideTitles: SideTitles(showTitles: false)),
        ),
        gridData: FlGridData(
          show: true,
          drawVerticalLine: false,
          horizontalInterval: _getMaxValue() / 4,
          getDrawingHorizontalLine: (value) {
            return FlLine(
              color: Colors.grey[300],
              strokeWidth: 1,
            );
          },
        ),
        borderData: FlBorderData(show: false),
        barGroups: _buildBarGroups(context),
      ),
    );
  }
  
  /// Constrói os grupos de barras do gráfico
  List<BarChartGroupData> _buildBarGroups(BuildContext context) {
    return List.generate(data.length, (index) {
      return BarChartGroupData(
        x: index,
        barRods: [
          BarChartRodData(
            toY: data[index].value,
            color: barColor ?? Theme.of(context).primaryColor,
            width: 20,
            borderRadius: const BorderRadius.only(
              topLeft: Radius.circular(6),
              topRight: Radius.circular(6),
            ),
          ),
        ],
      );
    });
  }
  
  /// Encontra o valor máximo nos dados para escalar o gráfico
  double _getMaxValue() {
    if (data.isEmpty) return 100;
    return data.map((e) => e.value).reduce((a, b) => a > b ? a : b);
  }
}
```

Este componente ChartCard encapsula toda a complexidade de configurar a biblioteca fl_chart, expondo apenas uma interface simples que recebe título e dados. Internamente, ele cuida de todos os detalhes de configuração do gráfico, incluindo tooltips interativos, formatação de eixos, e responsividade de fontes. Um desenvolvedor que usa este componente não precisa entender nada sobre fl_chart, apenas fornece os dados e obtém um gráfico profissional.

**Componente TopSellersList - Rankings e Listas:**

Listas de ranking são outro elemento comum em dashboards. Vamos criar um componente que mostra os top vendedores de forma atraente e responsiva.

```dart
// lib/widgets/dashboard/top_sellers_list.dart

import 'package:flutter/material.dart';
import '../../models/dashboard_data.dart';
import '../../core/responsive/responsive_values.dart';

/// Lista que exibe os top vendedores ranqueados por vendas.
class TopSellersList extends StatelessWidget {
  final List<SellerData> sellers;
  final int maxItems;  // Número máximo de itens a exibir
  
  const TopSellersList({
    Key? key,
    required this.sellers,
    this.maxItems = 5,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    // Ordena vendedores por vendas (descendente) e limita ao máximo
    final topSellers = [...sellers]
      ..sort((a, b) => b.sales.compareTo(a.sales))
      ..take(maxItems);
    
    return Card(
      elevation: 2,
      child: Padding(
        padding: EdgeInsets.all(
          ResponsiveValues.getHorizontalPadding(context),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Título da lista
            Text(
              'Top Vendedores',
              style: TextStyle(
                fontSize: ResponsiveValues.getSubtitleFontSize(context),
                fontWeight: FontWeight.bold,
              ),
            ),
            
            SizedBox(height: ResponsiveValues.getSectionSpacing(context)),
            
            // Lista de vendedores
            ...topSellers.asMap().entries.map((entry) {
              final index = entry.key;
              final seller = entry.value;
              return _buildSellerItem(context, seller, index);
            }).toList(),
          ],
        ),
      ),
    );
  }
  
  Widget _buildSellerItem(BuildContext context, SellerData seller, int index) {
    // Cores especiais para os 3 primeiros
    Color? medalColor;
    if (index == 0) medalColor = Colors.amber;       // Ouro
    else if (index == 1) medalColor = Colors.grey;   // Prata
    else if (index == 2) medalColor = Colors.brown;  // Bronze
    
    return Container(
      margin: EdgeInsets.only(
        bottom: ResponsiveValues.getElementSpacing(context),
      ),
      child: Row(
        children: [
          // Posição/medalha
          Container(
            width: 32,
            height: 32,
            decoration: BoxDecoration(
              color: medalColor ?? Colors.grey[300],
              shape: BoxShape.circle,
            ),
            child: Center(
              child: Text(
                '${index + 1}',
                style: TextStyle(
                  color: medalColor != null ? Colors.white : Colors.black87,
                  fontWeight: FontWeight.bold,
                  fontSize: ResponsiveValues.getBodyFontSize(context) * 0.9,
                ),
              ),
            ),
          ),
          
          SizedBox(width: ResponsiveValues.getElementSpacing(context)),
          
          // Nome do vendedor
          Expanded(
            child: Text(
              seller.name,
              style: TextStyle(
                fontSize: ResponsiveValues.getBodyFontSize(context),
                fontWeight: index < 3 ? FontWeight.w600 : FontWeight.normal,
              ),
            ),
          ),
          
          // Valor de vendas
          Text(
            'R\$ ${_formatSales(seller.sales)}',
            style: TextStyle(
              fontSize: ResponsiveValues.getBodyFontSize(context),
              fontWeight: FontWeight.bold,
              color: Theme.of(context).primaryColor,
            ),
          ),
        ],
      ),
    );
  }
  
  /// Formata o valor de vendas de forma compacta
  String _formatSales(double sales) {
    if (sales >= 1000000) {
      return '${(sales / 1000000).toStringAsFixed(1)}M';
    } else if (sales >= 1000) {
      return '${(sales / 1000).toStringAsFixed(1)}K';
    }
    return sales.toStringAsFixed(0);
  }
}
```

Este componente TopSellersList demonstra como criar interfaces visuais atraentes mesmo com dados simples. Note o uso de cores diferenciadas para os três primeiros lugares (ouro, prata, bronze), o que adiciona um elemento visual interessante e reforça a hierarquia do ranking. O componente também cuida automaticamente de ordenar os vendedores por vendas e limitar à quantidade especificada, removendo essa responsabilidade de quem o usa.

---

## ✅ CHECKPOINT 5

Concluímos a primeira parte do Módulo 5, onde planejamos cuidadosamente nosso dashboard e implementamos os três componentes fundamentais que serão reutilizados em todos os layouts. Criamos o MetricCard para exibir métricas com variações, o ChartCard para visualização gráfica de dados, e o TopSellersList para mostrar rankings.

No próximo slide, vamos montar estes componentes nos três diferentes layouts (mobile, tablet e desktop), demonstrando como a mesma base de componentes pode ser reorganizada para criar experiências otimizadas para cada tipo de dispositivo. Posso continuar?