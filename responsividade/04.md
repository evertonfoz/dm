# MÓDULO 4: ARQUITETURA E ORGANIZAÇÃO DE CÓDIGO RESPONSIVO

## **SLIDE 10: Estrutura de Pastas para Projetos Responsivos em Escala**

Quando desenvolvemos aplicações responsivas profissionais, a organização do código torna-se tão importante quanto a própria implementação técnica. Um projeto bem estruturado não apenas facilita a manutenção e evolução do código, mas também permite que equipes trabalhem de forma colaborativa sem conflitos ou confusão. Vamos explorar uma arquitetura de pastas que foi testada em projetos reais e que escala adequadamente conforme a complexidade cresce.

A estrutura que propomos segue princípios de separação de responsabilidades e coesão, onde cada pasta tem um propósito claro e específico. Isso significa que quando você ou outro desenvolvedor precisar fazer alterações relacionadas a responsividade, saberá exatamente onde procurar e onde adicionar código novo.

```
lib/
├── core/
│   ├── responsive/
│   │   ├── breakpoints.dart          # Definições de breakpoints da aplicação
│   │   ├── responsive_helper.dart    # Funções auxiliares para responsividade
│   │   ├── responsive_values.dart    # Valores adaptativos (paddings, fontes)
│   │   └── device_type.dart          # Enum e lógica de tipo de dispositivo
│   │
│   ├── constants/
│   │   ├── app_sizes.dart            # Tamanhos fixos usados na aplicação
│   │   └── app_spacing.dart          # Sistema de espaçamento consistente
│   │
│   └── theme/
│       └── responsive_theme.dart      # Temas adaptativos por dispositivo
│
├── widgets/
│   ├── layouts/
│   │   ├── responsive_layout.dart     # Widget que alterna entre layouts
│   │   ├── adaptive_scaffold.dart     # Scaffold que adapta navegação
│   │   └── responsive_grid.dart       # Grid com colunas adaptativas
│   │
│   └── responsive/
│       ├── responsive_text.dart       # Text com tamanho adaptativo
│       ├── responsive_padding.dart    # Padding que varia por dispositivo
│       └── responsive_card.dart       # Card com layout adaptativo
│
└── screens/
    ├── home/
    │   ├── home_screen.dart           # Entry point da tela
    │   ├── mobile_home.dart           # Layout específico para mobile
    │   ├── tablet_home.dart           # Layout específico para tablet
    │   └── desktop_home.dart          # Layout específico para desktop
    │
    └── product/
        ├── product_screen.dart
        ├── mobile_product.dart
        └── tablet_product.dart
```

Esta estrutura pode parecer extensa inicialmente, mas cada pasta serve um propósito específico que se tornará claro conforme implementamos. A pasta core/responsive centraliza toda a lógica de decisão sobre responsividade, garantindo que mudanças em breakpoints ou critérios de adaptação sejam feitas em um único lugar. A pasta widgets/layouts contém componentes reutilizáveis que encapsulam padrões comuns de layout responsivo, enquanto a pasta screens organiza as diferentes implementações de cada tela por tipo de dispositivo.

**Implementação do breakpoints.dart:**

Vamos começar implementando o arquivo que define os breakpoints da aplicação. Este arquivo será a fonte única de verdade para todas as decisões relacionadas a tamanhos de tela em todo o projeto.

```dart
// lib/core/responsive/breakpoints.dart

/// Classe que centraliza todos os breakpoints da aplicação.
/// Seguindo Material Design guidelines e análise de mercado de dispositivos.
class Breakpoints {
  // Previne instanciação desta classe utilitária
  Breakpoints._();
  
  /// Limite superior para dispositivos mobile (smartphones)
  /// Dispositivos até 600px são considerados mobile
  static const double mobile = 600;
  
  /// Limite superior para tablets pequenos e médios
  /// Entre 600px e 900px são considerados tablet
  static const double tablet = 900;
  
  /// Limite superior para tablets grandes e notebooks pequenos
  /// Entre 900px e 1200px são considerados desktop
  static const double desktop = 1200;
  
  /// Acima de 1200px são considerados telas large
  /// Incluindo monitores desktop e foldables totalmente expandidos
  
  /// Determina o tipo de dispositivo baseado na largura fornecida
  /// 
  /// Exemplo de uso:
  /// ```dart
  /// final width = MediaQuery.of(context).size.width;
  /// final deviceType = Breakpoints.getDeviceType(width);
  /// ```
  static DeviceType getDeviceType(double width) {
    if (width < mobile) {
      return DeviceType.mobile;
    } else if (width < tablet) {
      return DeviceType.tablet;
    } else if (width < desktop) {
      return DeviceType.desktop;
    } else {
      return DeviceType.large;
    }
  }
  
  /// Verifica se o contexto atual representa um dispositivo mobile
  /// Esta é uma função de conveniência muito usada
  static bool isMobile(BuildContext context) {
    return MediaQuery.of(context).size.width < mobile;
  }
  
  /// Verifica se o dispositivo é tablet ou maior
  /// Útil para mostrar/ocultar elementos disponíveis apenas em telas maiores
  static bool isTabletOrLarger(BuildContext context) {
    return MediaQuery.of(context).size.width >= mobile;
  }
  
  /// Verifica se o dispositivo é desktop ou maior
  /// Útil para layouts que só fazem sentido em telas amplas
  static bool isDesktopOrLarger(BuildContext context) {
    return MediaQuery.of(context).size.width >= desktop;
  }
  
  /// Retorna a largura disponível do contexto
  /// Função auxiliar para reduzir verbosidade
  static double getWidth(BuildContext context) {
    return MediaQuery.of(context).size.width;
  }
  
  /// Retorna a altura disponível do contexto
  static double getHeight(BuildContext context) {
    return MediaQuery.of(context).size.height;
  }
}

/// Enumeração que representa os tipos de dispositivo suportados
/// Facilita o uso de switch statements e torna o código mais legível
enum DeviceType {
  mobile,
  tablet,
  desktop,
  large,
}

/// Extension methods para adicionar funcionalidades ao enum DeviceType
extension DeviceTypeExtension on DeviceType {
  /// Retorna uma descrição legível do tipo de dispositivo
  String get description {
    switch (this) {
      case DeviceType.mobile:
        return 'Smartphone';
      case DeviceType.tablet:
        return 'Tablet';
      case DeviceType.desktop:
        return 'Desktop/Laptop';
      case DeviceType.large:
        return 'Tela Grande';
    }
  }
  
  /// Retorna true se o dispositivo é considerado compacto
  /// Útil para decisões de UX que agrupam mobile e tablet
  bool get isCompact {
    return this == DeviceType.mobile || this == DeviceType.tablet;
  }
}
```

A implementação acima não apenas define os valores de breakpoint, mas também fornece uma série de métodos auxiliares que tornam o código consumidor muito mais limpo e expressivo. Note como utilizamos const para os valores dos breakpoints, garantindo que eles sejam compilados como constantes e não consumam memória desnecessária em runtime.

**Implementação do responsive_values.dart:**

Agora vamos implementar o sistema de valores adaptativos, que permite que espaçamentos, tamanhos de fonte e outros valores numéricos se adaptem automaticamente ao tipo de dispositivo.

```dart
// lib/core/responsive/responsive_values.dart

import 'package:flutter/material.dart';
import 'breakpoints.dart';

/// Classe que fornece valores adaptativos baseados no tipo de dispositivo.
/// Centraliza decisões sobre tamanhos, espaçamentos e proporções.
class ResponsiveValues {
  ResponsiveValues._();
  
  /// Retorna padding horizontal apropriado para o dispositivo
  /// Mobile: mais compacto para aproveitar espaço limitado
  /// Tablet/Desktop: mais espaçoso para melhor legibilidade
  static double getHorizontalPadding(BuildContext context) {
    final deviceType = Breakpoints.getDeviceType(
      MediaQuery.of(context).size.width,
    );
    
    switch (deviceType) {
      case DeviceType.mobile:
        return 16.0;  // Padding padrão mobile
      case DeviceType.tablet:
        return 24.0;  // Mais espaçoso em tablet
      case DeviceType.desktop:
        return 32.0;  // Ainda mais espaçoso em desktop
      case DeviceType.large:
        return 48.0;  // Máximo espaçamento para telas grandes
    }
  }
  
  /// Retorna padding vertical apropriado
  /// Geralmente menor que horizontal para aproveitar altura da tela
  static double getVerticalPadding(BuildContext context) {
    final horizontalPadding = getHorizontalPadding(context);
    return horizontalPadding * 0.75;  // 75% do horizontal
  }
  
  /// Retorna EdgeInsets simétrico adaptativo
  /// Uso mais comum para padding geral de telas
  static EdgeInsets getScreenPadding(BuildContext context) {
    return EdgeInsets.symmetric(
      horizontal: getHorizontalPadding(context),
      vertical: getVerticalPadding(context),
    );
  }
  
  /// Sistema de tamanhos de fonte adaptativo
  /// Segue progressão visual harmoniosa entre dispositivos
  
  /// Tamanho de fonte para títulos principais (h1)
  static double getTitleFontSize(BuildContext context) {
    final deviceType = Breakpoints.getDeviceType(
      MediaQuery.of(context).size.width,
    );
    
    switch (deviceType) {
      case DeviceType.mobile:
        return 24.0;
      case DeviceType.tablet:
        return 28.0;
      case DeviceType.desktop:
        return 32.0;
      case DeviceType.large:
        return 36.0;
    }
  }
  
  /// Tamanho de fonte para subtítulos (h2)
  static double getSubtitleFontSize(BuildContext context) {
    return getTitleFontSize(context) * 0.75;  // 75% do título
  }
  
  /// Tamanho de fonte para corpo de texto
  static double getBodyFontSize(BuildContext context) {
    final deviceType = Breakpoints.getDeviceType(
      MediaQuery.of(context).size.width,
    );
    
    switch (deviceType) {
      case DeviceType.mobile:
        return 14.0;
      case DeviceType.tablet:
        return 16.0;
      case DeviceType.desktop:
      case DeviceType.large:
        return 16.0;  // Não aumenta muito em desktop para manter legibilidade
    }
  }
  
  /// Espaçamento entre elementos relacionados
  static double getElementSpacing(BuildContext context) {
    final deviceType = Breakpoints.getDeviceType(
      MediaQuery.of(context).size.width,
    );
    
    switch (deviceType) {
      case DeviceType.mobile:
        return 8.0;
      case DeviceType.tablet:
        return 12.0;
      case DeviceType.desktop:
      case DeviceType.large:
        return 16.0;
    }
  }
  
  /// Espaçamento entre seções distintas
  static double getSectionSpacing(BuildContext context) {
    return getElementSpacing(context) * 2;  // Dobro do espaçamento de elementos
  }
  
  /// Largura máxima para conteúdo textual
  /// Previne linhas excessivamente longas em telas grandes
  /// Baseado em princípios de tipografia (45-75 caracteres por linha)
  static double getMaxContentWidth(BuildContext context) {
    final deviceType = Breakpoints.getDeviceType(
      MediaQuery.of(context).size.width,
    );
    
    switch (deviceType) {
      case DeviceType.mobile:
        return double.infinity;  // Usa toda largura disponível
      case DeviceType.tablet:
        return 600.0;  // Limita para melhor legibilidade
      case DeviceType.desktop:
        return 800.0;
      case DeviceType.large:
        return 1000.0;  // Mesmo em telas grandes, limita para conforto visual
    }
  }
  
  /// Número de colunas apropriado para grids
  /// Usado em GridView para adaptar densidade de informação
  static int getGridColumnCount(BuildContext context) {
    final deviceType = Breakpoints.getDeviceType(
      MediaQuery.of(context).size.width,
    );
    
    switch (deviceType) {
      case DeviceType.mobile:
        return 2;  // Duas colunas em mobile
      case DeviceType.tablet:
        return 3;  // Três colunas em tablet
      case DeviceType.desktop:
        return 4;  // Quatro colunas em desktop
      case DeviceType.large:
        return 5;  // Cinco colunas em telas muito grandes
    }
  }
  
  /// Altura de AppBar adaptativa
  static double getAppBarHeight(BuildContext context) {
    return Breakpoints.isMobile(context) ? 56.0 : 64.0;
  }
  
  /// Altura de botões primários adaptativa
  static double getButtonHeight(BuildContext context) {
    return Breakpoints.isMobile(context) ? 48.0 : 52.0;
  }
}
```

Esta classe ResponsiveValues encapsula toda a inteligência sobre como valores numéricos devem se adaptar entre dispositivos. O benefício principal desta abordagem é que você pode ajustar estes valores em um único lugar e todas as telas da aplicação se beneficiarão automaticamente das mudanças. Isso promove consistência visual e facilita enormemente a manutenção do design system da aplicação.

---

## **SLIDE 11: Widget ResponsiveLayout - Alternando Entre Implementações**

Com nossa infraestrutura de breakpoints e valores estabelecida, podemos agora criar widgets de alto nível que facilitam a alternância entre diferentes implementações de layout baseadas no tipo de dispositivo. O widget ResponsiveLayout é a peça central desta arquitetura, permitindo que você defina diferentes widgets para diferentes tamanhos de tela de forma declarativa e elegante.

A filosofia por trás deste widget é simples mas poderosa: em vez de encher uma única classe com múltiplos if-else statements verificando tamanhos de tela, você cria implementações separadas para cada tipo de dispositivo e deixa o ResponsiveLayout fazer o roteamento automático. Isso resulta em código mais limpo, mais testável e mais fácil de manter.

```dart
// lib/widgets/layouts/responsive_layout.dart

import 'package:flutter/material.dart';
import '../../core/responsive/breakpoints.dart';

/// Widget que alterna entre diferentes layouts baseado no tipo de dispositivo.
/// 
/// Este é o widget fundamental para implementar design adaptativo.
/// Você fornece diferentes implementações de widget para cada tipo de dispositivo
/// e o ResponsiveLayout automaticamente exibe o apropriado.
/// 
/// Exemplo de uso:
/// ```dart
/// ResponsiveLayout(
///   mobile: MobileHomeScreen(),
///   tablet: TabletHomeScreen(),
///   desktop: DesktopHomeScreen(),
/// )
/// ```
class ResponsiveLayout extends StatelessWidget {
  /// Layout obrigatório para dispositivos mobile
  /// Este é o único parâmetro obrigatório pois seguimos mobile-first approach
  final Widget mobile;
  
  /// Layout opcional para tablets
  /// Se não fornecido, usa o layout mobile
  final Widget? tablet;
  
  /// Layout opcional para desktop
  /// Se não fornecido, usa tablet (se disponível) ou mobile
  final Widget? desktop;
  
  /// Layout opcional para telas large
  /// Se não fornecido, usa desktop, tablet ou mobile (nessa ordem de fallback)
  final Widget? large;
  
  const ResponsiveLayout({
    Key? key,
    required this.mobile,
    this.tablet,
    this.desktop,
    this.large,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    // Obtém o tipo de dispositivo atual
    final deviceType = Breakpoints.getDeviceType(
      MediaQuery.of(context).size.width,
    );
    
    // Implementa lógica de fallback em cascata
    // Sempre tenta usar a implementação mais específica disponível
    switch (deviceType) {
      case DeviceType.mobile:
        return mobile;
        
      case DeviceType.tablet:
        // Usa tablet se disponível, caso contrário fallback para mobile
        return tablet ?? mobile;
        
      case DeviceType.desktop:
        // Tenta desktop → tablet → mobile
        return desktop ?? tablet ?? mobile;
        
      case DeviceType.large:
        // Tenta large → desktop → tablet → mobile
        return large ?? desktop ?? tablet ?? mobile;
    }
  }
}
```

O sistema de fallback implementado aqui é intencional e segue o princípio de progressive enhancement. Você sempre precisa fornecer um layout mobile (pois é o caso base e mais restritivo), mas pode opcionalmente fornecer implementações especializadas para dispositivos maiores. Se uma implementação específica não estiver disponível, o widget automaticamente "desce" para a próxima melhor opção.

**Criando um AdaptiveScaffold:**

Vamos expandir este conceito criando um Scaffold que adapta automaticamente sua navegação baseado no tamanho da tela. Este é um padrão extremamente comum em aplicações profissionais, onde mobile usa BottomNavigationBar, tablets médios usam NavigationRail e telas grandes usam Drawer permanente.

```dart
// lib/widgets/layouts/adaptive_scaffold.dart

import 'package:flutter/material.dart';
import '../../core/responsive/breakpoints.dart';

/// Scaffold que adapta automaticamente o tipo de navegação baseado no dispositivo.
/// 
/// - Mobile: BottomNavigationBar
/// - Tablet: NavigationRail
/// - Desktop: NavigationRail expandido ou Drawer permanente
class AdaptiveScaffold extends StatelessWidget {
  /// Título exibido no AppBar
  final String title;
  
  /// Conteúdo principal da tela
  final Widget body;
  
  /// Lista de destinos de navegação
  final List<NavigationDestination> destinations;
  
  /// Índice do destino atualmente selecionado
  final int currentIndex;
  
  /// Callback quando um destino é selecionado
  final ValueChanged<int> onDestinationSelected;
  
  /// FloatingActionButton opcional
  final Widget? floatingActionButton;
  
  const AdaptiveScaffold({
    Key? key,
    required this.title,
    required this.body,
    required this.destinations,
    required this.currentIndex,
    required this.onDestinationSelected,
    this.floatingActionButton,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    final isMobile = Breakpoints.isMobile(context);
    final isTablet = !isMobile && 
                     !Breakpoints.isDesktopOrLarger(context);
    
    // Em mobile: usa BottomNavigationBar tradicional
    if (isMobile) {
      return Scaffold(
        appBar: AppBar(
          title: Text(title),
          elevation: 2,
        ),
        body: body,
        bottomNavigationBar: NavigationBar(
          selectedIndex: currentIndex,
          onDestinationSelected: onDestinationSelected,
          destinations: destinations,
        ),
        floatingActionButton: floatingActionButton,
      );
    }
    
    // Em tablet e desktop: usa NavigationRail lateral
    return Scaffold(
      body: Row(
        children: [
          // NavigationRail à esquerda
          NavigationRail(
            // Expandido em desktop, compacto em tablet
            extended: Breakpoints.isDesktopOrLarger(context),
            selectedIndex: currentIndex,
            onDestinationSelected: onDestinationSelected,
            labelType: isTablet 
                ? NavigationRailLabelType.all 
                : NavigationRailLabelType.none,
            destinations: destinations.map((destination) {
              return NavigationRailDestination(
                icon: destination.icon,
                selectedIcon: destination.selectedIcon,
                label: Text(destination.label),
              );
            }).toList(),
          ),
          
          // Divider vertical para separação visual
          const VerticalDivider(thickness: 1, width: 1),
          
          // Conteúdo principal expandido
          Expanded(
            child: Column(
              children: [
                // AppBar no topo do conteúdo
                AppBar(
                  title: Text(title),
                  elevation: 2,
                ),
                // Conteúdo expandido
                Expanded(child: body),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: floatingActionButton,
    );
  }
}

/// Classe que representa um destino de navegação
/// Similar ao NavigationDestination mas com mais flexibilidade
class NavigationDestination {
  final Widget icon;
  final Widget? selectedIcon;
  final String label;
  
  const NavigationDestination({
    required this.icon,
    this.selectedIcon,
    required this.label,
  });
}
```

Este AdaptiveScaffold encapsula toda a complexidade de adaptar a navegação entre dispositivos. Quando você usa este widget, não precisa se preocupar com os detalhes de implementação de cada tipo de navegação, apenas fornece os destinos e o scaffold cuida do resto automaticamente.

---

## **SLIDE 12: Organização de Telas por Tipo de Dispositivo**

A última peça da nossa arquitetura é a organização de telas individuais. Para telas complexas onde o layout muda significativamente entre dispositivos, a melhor prática é criar arquivos separados para cada implementação. Isso mantém cada arquivo focado e simples, evitando o problema comum de ter um único arquivo com centenas de linhas cheio de condicionais.

Vamos implementar um exemplo completo de uma tela Home organizada desta forma:

```dart
// lib/screens/home/home_screen.dart

import 'package:flutter/material.dart';
import '../../widgets/layouts/responsive_layout.dart';
import 'mobile_home.dart';
import 'tablet_home.dart';
import 'desktop_home.dart';

/// Entry point da tela Home.
/// Este arquivo apenas coordena qual implementação exibir.
/// A lógica de cada layout está em arquivos separados.
class HomeScreen extends StatelessWidget {
  const HomeScreen({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return ResponsiveLayout(
      mobile: MobileHome(),
      tablet: TabletHome(),
      desktop: DesktopHome(),
      // Não fornecemos 'large', então usará desktop em telas muito grandes
    );
  }
}
```

Este arquivo de entrada é intencionalmente minimalista. Ele apenas orquestra qual implementação deve ser exibida, delegando toda a lógica específica de layout para os arquivos especializados. Isso torna extremamente fácil adicionar ou modificar implementações específicas de dispositivo sem afetar as outras.

```dart
// lib/screens/home/mobile_home.dart

import 'package:flutter/material.dart';
import '../../core/responsive/responsive_values.dart';

/// Implementação mobile da tela Home.
/// Layout vertical otimizado para telas pequenas.
class MobileHome extends StatelessWidget {
  const MobileHome({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Home - Mobile'),
      ),
      body: ListView(
        padding: ResponsiveValues.getScreenPadding(context),
        children: [
          // Card de destaque ocupa largura total
          _buildFeaturedCard(context),
          
          SizedBox(height: ResponsiveValues.getSectionSpacing(context)),
          
          // Lista vertical de itens
          _buildItemsList(context),
        ],
      ),
    );
  }
  
  Widget _buildFeaturedCard(BuildContext context) {
    return Card(
      child: Padding(
        padding: EdgeInsets.all(ResponsiveValues.getHorizontalPadding(context)),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Item em Destaque',
              style: TextStyle(
                fontSize: ResponsiveValues.getTitleFontSize(context),
                fontWeight: FontWeight.bold,
              ),
            ),
            SizedBox(height: ResponsiveValues.getElementSpacing(context)),
            const Text('Descrição do item em destaque...'),
          ],
        ),
      ),
    );
  }
  
  Widget _buildItemsList(BuildContext context) {
    // Em mobile: lista vertical simples
    return Column(
      children: List.generate(
        5,
        (index) => Card(
          margin: EdgeInsets.only(
            bottom: ResponsiveValues.getElementSpacing(context),
          ),
          child: ListTile(
            leading: const Icon(Icons.article),
            title: Text('Item ${index + 1}'),
            subtitle: const Text('Descrição breve'),
          ),
        ),
      ),
    );
  }
}
```

A implementação mobile é focada em layout vertical, fazendo uso eficiente do espaço limitado em largura. Todos os valores de espaçamento e tamanhos de fonte são obtidos através do ResponsiveValues, garantindo consistência com o resto da aplicação.

```dart
// lib/screens/home/tablet_home.dart

import 'package:flutter/material.dart';
import '../../core/responsive/responsive_values.dart';

/// Implementação tablet da tela Home.
/// Layout que aproveita largura extra com grid de 2 colunas.
class TabletHome extends StatelessWidget {
  const TabletHome({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Home - Tablet'),
      ),
      body: Padding(
        padding: ResponsiveValues.getScreenPadding(context),
        child: CustomScrollView(
          slivers: [
            // Card de destaque em banner horizontal
            SliverToBoxAdapter(
              child: _buildFeaturedBanner(context),
            ),
            
            SliverToBoxAdapter(
              child: SizedBox(
                height: ResponsiveValues.getSectionSpacing(context),
              ),
            ),
            
            // Grid de 2 colunas para itens
            SliverGrid(
              gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: 2,
                crossAxisSpacing: 16,
                mainAxisSpacing: 16,
                childAspectRatio: 1.5,
              ),
              delegate: SliverChildBuilderDelegate(
                (context, index) => _buildGridItem(context, index),
                childCount: 6,
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildFeaturedBanner(BuildContext context) {
    return Card(
      child: Padding(
        padding: EdgeInsets.all(ResponsiveValues.getHorizontalPadding(context)),
        child: Row(
          children: [
            // Imagem à esquerda
            Container(
              width: 150,
              height: 150,
              color: Colors.grey[300],
              child: const Icon(Icons.image, size: 50),
            ),
            SizedBox(width: ResponsiveValues.getElementSpacing(context)),
            // Conteúdo à direita
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    'Item em Destaque',
                    style: TextStyle(
                      fontSize: ResponsiveValues.getTitleFontSize(context),
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  SizedBox(height: ResponsiveValues.getElementSpacing(context)),
                  const Text('Descrição mais detalhada do item...'),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
  
  Widget _buildGridItem(BuildContext context, int index) {
    return Card(
      child: Padding(
        padding: EdgeInsets.all(ResponsiveValues.getHorizontalPadding(context)),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.article, size: 40, color: Colors.blue),
            SizedBox(height: ResponsiveValues.getElementSpacing(context)),
            Text(
              'Item ${index + 1}',
              style: TextStyle(
                fontSize: ResponsiveValues.getSubtitleFontSize(context),
                fontWeight: FontWeight.bold,
              ),
            ),
            const Text('Descrição do item'),
          ],
        ),
      ),
    );
  }
}
```

A implementação para tablet aproveita o espaço horizontal adicional reorganizando o conteúdo em um grid de duas colunas. O card em destaque também muda para um layout horizontal, com imagem à esquerda e texto à direita, aproveitando melhor o formato landscape típico de tablets.

Esta abordagem de arquitetura separada por arquivo torna extremamente simples iterar em cada implementação independentemente, facilita code review pois mudanças são isoladas, e permite que desenvolvedores diferentes trabalhem em diferentes versões simultaneamente sem conflitos.

---

## ✅ CHECKPOINT 4

Concluímos o Módulo 4 sobre arquitetura e organização, estabelecendo uma estrutura de projeto profissional e escalável. Implementamos breakpoints centralizados, valores adaptativos, widgets de layout responsivo e demonstramos como organizar telas complexas em arquivos separados por tipo de dispositivo.

Posso prosseguir para o Módulo 5 sobre implementação prática de um dashboard responsivo completo?