# MÓDULO 2: FERRAMENTAS DO FLUTTER PARA RESPONSIVIDADE

## **SLIDE 4: MediaQuery - A Fonte de Informações do Dispositivo**

O MediaQuery é a ferramenta fundamental para obter informações sobre o ambiente de execução da sua aplicação. Pense nele como um "sensor" que fornece dados críticos sobre o dispositivo onde seu aplicativo está rodando.

**Como Funciona:**
O MediaQuery herda informações do contexto da árvore de widgets e as disponibiliza através de uma API simples. Ele é atualizado automaticamente quando o dispositivo muda de orientação ou quando configurações do sistema são alteradas.

```dart
// Obtendo dados do dispositivo
class ResponsiveScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    // Captura todas as informações de mídia do dispositivo
    final mediaQuery = MediaQuery.of(context);
    
    // Dimensões da tela (em pixels lógicos)
    final screenWidth = mediaQuery.size.width;   // Largura total disponível
    final screenHeight = mediaQuery.size.height; // Altura total disponível
    
    // Orientação atual do dispositivo
    final orientation = mediaQuery.orientation;  // portrait ou landscape
    
    // Informações de padding do sistema (notch, barras de status/navegação)
    final topPadding = mediaQuery.padding.top;    // Espaço da barra de status
    final bottomPadding = mediaQuery.padding.bottom; // Espaço da barra de navegação
    
    // Densidade de pixels (para imagens de alta resolução)
    final pixelRatio = mediaQuery.devicePixelRatio;
    
    return Container(
      // Exemplo: largura de 90% da tela, independente do dispositivo
      width: screenWidth * 0.9,
      child: Text('Largura: ${screenWidth.toStringAsFixed(0)}px'),
    );
  }
}
```

**Propriedades Mais Úteis:**

A propriedade `size` retorna as dimensões utilizáveis da tela. Note que este valor já considera áreas ocupadas pelo sistema operacional quando apropriado.

A propriedade `orientation` indica se o dispositivo está em modo retrato ou paisagem, essencial para reorganizar layouts.

A propriedade `padding` fornece os espaços ocupados por elementos do sistema como notch, barra de status e barras de navegação. Isso é crucial para evitar que seu conteúdo fique escondido atrás desses elementos.

A propriedade `devicePixelRatio` informa quantos pixels físicos existem por pixel lógico, útil para carregar imagens na resolução apropriada.

**Caso Real - Problema e Solução:**

Imagine que você cria um botão fixo no rodapé da tela, mas em alguns dispositivos ele fica parcialmente escondido pela barra de navegação do sistema. Aqui está como o MediaQuery resolve isso:

```dart
// ❌ ERRADO: Ignora áreas do sistema
Positioned(
  bottom: 0, // Pode ficar atrás da barra de navegação!
  child: MyButton(),
)

// ✅ CORRETO: Respeita padding do sistema
Positioned(
  bottom: MediaQuery.of(context).padding.bottom, // Adiciona espaço seguro
  child: MyButton(),
)
```

**Armadilha Comum:**
Evite chamar `MediaQuery.of(context)` múltiplas vezes no mesmo método. Isso é ineficiente. Capture uma vez no início do método build e reutilize a referência.

---

## **SLIDE 5: LayoutBuilder - Layouts Dinâmicos Baseados em Constraints**

Enquanto o MediaQuery fornece informações sobre a tela inteira, o LayoutBuilder permite que você tome decisões de layout baseadas no espaço disponível para um widget específico. Esta é uma distinção fundamental para criar componentes verdadeiramente reutilizáveis.

**Por Que LayoutBuilder é Diferente:**

Imagine que você tem um Card que pode ser usado tanto em uma tela completa quanto dentro de um Dialog menor. O MediaQuery sempre retornaria o tamanho da tela completa, mas o LayoutBuilder retorna as constraints específicas do espaço onde o Card está sendo renderizado.

```dart
// Componente que adapta seu layout ao espaço disponível
class AdaptiveCard extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        // constraints.maxWidth = largura DISPONÍVEL para este widget
        // Não necessariamente a largura da tela!
        
        final availableWidth = constraints.maxWidth;
        final availableHeight = constraints.maxHeight;
        
        // Decisão baseada no espaço real disponível
        if (availableWidth < 300) {
          // Layout compacto: elementos empilhados verticalmente
          return Column(
            children: [
              _buildImage(),
              _buildTitle(),
              _buildDescription(),
            ],
          );
        } else {
          // Layout expandido: elementos lado a lado
          return Row(
            children: [
              Expanded(flex: 2, child: _buildImage()),
              Expanded(
                flex: 3,
                child: Column(
                  children: [
                    _buildTitle(),
                    _buildDescription(),
                  ],
                ),
              ),
            ],
          );
        }
      },
    );
  }
  
  Widget _buildImage() => Placeholder(fallbackHeight: 100);
  Widget _buildTitle() => Text('Título', style: TextStyle(fontSize: 18));
  Widget _buildDescription() => Text('Descrição do produto...');
}
```

**Quando Usar Cada Um:**

Use MediaQuery quando precisar de informações globais sobre o dispositivo, como decidir entre layouts completamente diferentes para mobile versus tablet, ou quando precisar considerar áreas seguras do sistema operacional.

Use LayoutBuilder quando estiver criando componentes reutilizáveis que precisam se adaptar ao seu container pai, independentemente do tamanho da tela. Isso torna seus widgets muito mais flexíveis e composáveis.

**Exemplo Prático - GridView Adaptativo:**

```dart
// Grid que ajusta número de colunas baseado no espaço disponível
LayoutBuilder(
  builder: (context, constraints) {
    // Calcula quantas colunas cabem (mínimo 150px por coluna)
    final columnCount = (constraints.maxWidth / 150).floor();
    
    return GridView.builder(
      gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: columnCount.clamp(1, 4), // Entre 1 e 4 colunas
        crossAxisSpacing: 8,
        mainAxisSpacing: 8,
      ),
      itemBuilder: (context, index) => ProductCard(),
    );
  },
)
```

Este exemplo demonstra como o LayoutBuilder permite que o mesmo componente funcione perfeitamente tanto em um Dialog estreito quanto na tela principal de um tablet.

---

## **SLIDE 6: Breakpoints - Categorizando Dispositivos**

Breakpoints são pontos de transição onde o layout da sua aplicação muda significativamente. Eles são essenciais para implementar design adaptativo de forma organizada e previsível.

**Padrão Industrial de Breakpoints:**

Baseado em estudos de mercado e padrões do Material Design, aqui está uma categorização robusta que funciona para a maioria dos casos:

```dart
// classe auxiliar para gerenciar breakpoints
class Breakpoints {
  // Valores em pixels lógicos
  static const double mobile = 600;    // Até 600: smartphones
  static const double tablet = 900;    // 601-900: tablets pequenos
  static const double desktop = 1200;  // 901-1200: tablets grandes
  // Acima de 1200: desktop/foldables expandidos
  
  // Método para determinar tipo de dispositivo
  static DeviceType getDeviceType(double width) {
    if (width < mobile) return DeviceType.mobile;
    if (width < tablet) return DeviceType.tablet;
    if (width < desktop) return DeviceType.desktop;
    return DeviceType.large;
  }
  
  // Verifica se está em modo mobile
  static bool isMobile(BuildContext context) {
    return MediaQuery.of(context).size.width < mobile;
  }
  
  // Verifica se está em modo tablet ou maior
  static bool isTabletOrLarger(BuildContext context) {
    return MediaQuery.of(context).size.width >= mobile;
  }
}

enum DeviceType { mobile, tablet, desktop, large }
```

**Aplicação Prática - Widget Responsivo:**

Vamos criar um widget que utiliza estes breakpoints para adaptar seu layout de forma clara e manutenível:

```dart
class ResponsiveLayout extends StatelessWidget {
  final Widget mobile;
  final Widget? tablet;  // Opcional: usa mobile se não fornecido
  final Widget? desktop; // Opcional: usa tablet se não fornecido
  
  const ResponsiveLayout({
    required this.mobile,
    this.tablet,
    this.desktop,
  });
  
  @override
  Widget build(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    
    // Lógica de fallback: desktop → tablet → mobile
    if (width >= Breakpoints.desktop) {
      return desktop ?? tablet ?? mobile;
    } else if (width >= Breakpoints.mobile) {
      return tablet ?? mobile;
    } else {
      return mobile;
    }
  }
}

// USO PRÁTICO:
ResponsiveLayout(
  mobile: MobileHomeScreen(),      // Sempre obrigatório
  tablet: TabletHomeScreen(),      // Usa mobile se omitido
  desktop: DesktopHomeScreen(),    // Usa tablet se omitido
)
```

**Boa Prática - Valores Responsivos:**

Além de mudar layouts, você também deve adaptar valores como espaçamentos, tamanhos de fonte e paddings:

```dart
class ResponsiveValues {
  // Retorna padding apropriado baseado no dispositivo
  static double getPadding(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    if (width < Breakpoints.mobile) return 16.0;      // Mobile: compacto
    if (width < Breakpoints.tablet) return 24.0;      // Tablet: médio
    return 32.0;                                      // Desktop: espaçoso
  }
  
  // Retorna tamanho de fonte do título
  static double getTitleFontSize(BuildContext context) {
    final width = MediaQuery.of(context).size.width;
    if (width < Breakpoints.mobile) return 20.0;
    if (width < Breakpoints.tablet) return 24.0;
    return 28.0;
  }
}

// USO:
Padding(
  padding: EdgeInsets.all(ResponsiveValues.getPadding(context)),
  child: Text(
    'Título',
    style: TextStyle(
      fontSize: ResponsiveValues.getTitleFontSize(context),
    ),
  ),
)
```

**Consideração Importante:**
Os breakpoints sugeridos são pontos de partida testados, mas você pode e deve ajustá-los baseado nas necessidades específicas do seu projeto e público-alvo. O importante é ter valores consistentes em toda a aplicação.

---

## ✅ CHECKPOINT 2

Completamos o Módulo 2 com três slides focados nas ferramentas essenciais. Antes de prosseguir para o Módulo 3 sobre widgets responsivos, gostaria de confirmar se o nível de detalhe técnico e a progressão didática estão adequados. 

Na próxima etapa abordaremos Expanded, Flexible, FractionallySizedBox e AspectRatio com exemplos práticos de quando usar cada um. Posso continuar?