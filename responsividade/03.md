# MÓDULO 3: WIDGETS RESPONSIVOS FUNDAMENTAIS

## **SLIDE 7: Expanded e Flexible - Controlando Proporções Dinâmicas**

Quando trabalhamos com layouts responsivos, um dos desafios mais comuns é distribuir espaço disponível entre múltiplos elementos de forma inteligente. Os widgets Expanded e Flexible foram projetados especificamente para resolver este problema, permitindo que seus componentes cresçam e se adaptem ao espaço disponível de maneira proporcional e previsível.

**Entendendo o Expanded:**

O widget Expanded é utilizado dentro de Row, Column ou Flex, e força um filho a ocupar todo o espaço disponível restante no eixo principal. Pense nele como um elemento "ganancioso" que expande para preencher qualquer vazio. Este comportamento é extremamente útil quando você quer que um elemento específico utilize todo o espaço que sobrar após os outros elementos ocuparem suas posições.

```dart
// Exemplo básico: elemento central expansível
Row(
  children: [
    // Elemento fixo à esquerda (largura definida)
    Container(
      width: 100,
      color: Colors.blue,
      child: Text('Fixo'),
    ),
    
    // Elemento expansível no centro (ocupa espaço restante)
    Expanded(
      child: Container(
        color: Colors.green,
        child: Text('Expande para preencher'),
      ),
    ),
    
    // Elemento fixo à direita
    Container(
      width: 80,
      color: Colors.red,
      child: Text('Fixo'),
    ),
  ],
)
```

Neste exemplo, independentemente do tamanho da tela, os elementos azul e vermelho sempre terão 100 e 80 pixels respectivamente, enquanto o elemento verde automaticamente ajustará sua largura para preencher todo o espaço intermediário disponível.

**O Poder do Parâmetro flex:**

O verdadeiro poder do Expanded emerge quando utilizamos múltiplos elementos expansíveis com diferentes valores de flex. Este parâmetro define a proporção relativa que cada elemento deve ocupar do espaço disponível. Pense no flex como "partes" de um todo, onde o espaço total é dividido proporcionalmente entre os elementos.

```dart
// Distribuição proporcional de espaço
Column(
  children: [
    // Ocupa 1 parte do espaço total (1/6 do disponível)
    Expanded(
      flex: 1,
      child: Container(
        color: Colors.red,
        child: Center(child: Text('flex: 1')),
      ),
    ),
    
    // Ocupa 2 partes do espaço total (2/6 = 1/3 do disponível)
    Expanded(
      flex: 2,
      child: Container(
        color: Colors.green,
        child: Center(child: Text('flex: 2')),
      ),
    ),
    
    // Ocupa 3 partes do espaço total (3/6 = 1/2 do disponível)
    Expanded(
      flex: 3,
      child: Container(
        color: Colors.blue,
        child: Center(child: Text('flex: 3')),
      ),
    ),
  ],
)
// Total de partes: 1+2+3 = 6 partes
// Vermelho = 1/6, Verde = 2/6 (33%), Azul = 3/6 (50%)
```

Esta abordagem é particularmente poderosa porque as proporções se mantêm constantes independentemente do tamanho da tela. Se você tiver 300 pixels disponíveis ou 1000 pixels, a distribuição proporcional permanece idêntica.

**Diferença entre Expanded e Flexible:**

Enquanto Expanded força o filho a ocupar todo o espaço alocado, o Flexible permite que o filho decida se quer ou não utilizar todo o espaço disponível. Esta distinção sutil mas importante afeta como o widget filho se comporta dentro do espaço alocado.

```dart
// Comparação direta entre Flexible e Expanded
Row(
  children: [
    // Flexible: aloca espaço, mas o filho pode usar menos
    Flexible(
      flex: 1,
      child: Container(
        width: 50, // Pode especificar tamanho próprio!
        color: Colors.orange,
        child: Text('Flexible'),
      ),
    ),
    
    // Expanded: força o filho a ocupar todo espaço alocado
    Expanded(
      flex: 1,
      child: Container(
        // width ignorada! Sempre expande totalmente
        color: Colors.purple,
        child: Text('Expanded'),
      ),
    ),
  ],
)
```

No exemplo acima, o Flexible reserva seu espaço proporcional mas permite que o Container interno use apenas 50 pixels de largura, deixando o restante vazio. Já o Expanded ignora qualquer tentativa do filho de definir sua própria largura e o força a ocupar toda a largura alocada.

**Quando Usar Cada Um:**

Use Expanded quando você quer garantir que um elemento sempre preencha completamente seu espaço alocado, como em barras de navegação, cabeçalhos de seção, ou áreas de conteúdo principal que devem sempre ocupar todo o espaço disponível.

Use Flexible quando você quer dar flexibilidade ao elemento filho para decidir seu tamanho, mas ainda assim participar da distribuição proporcional de espaço. Isso é útil para botões que tem um tamanho mínimo mas podem crescer se houver espaço, ou para textos que podem ter tamanhos variáveis mas não devem causar overflow.

---

## **SLIDE 8: FractionallySizedBox e AspectRatio - Dimensionamento Preciso**

Além de distribuir espaço proporcionalmente entre irmãos, frequentemente precisamos dimensionar um único widget como uma fração específica de seu pai ou manter proporções específicas de aspecto. Para estas situações, o Flutter oferece dois widgets especializados que tornam essas tarefas triviais.

**FractionallySizedBox - Tamanhos Relativos ao Pai:**

O FractionallySizedBox permite que você defina o tamanho de um widget como uma porcentagem exata do espaço disponível oferecido por seu pai. Diferentemente do Expanded que divide espaço entre irmãos, o FractionallySizedBox trabalha com a relação pai-filho, oferecendo controle preciso sobre dimensionamento relativo.

```dart
// Widget que ocupa porcentagem específica do pai
Container(
  width: 400,  // Container pai com largura fixa
  height: 300,
  color: Colors.grey[300],
  child: Center(
    child: FractionallySizedBox(
      widthFactor: 0.8,   // 80% da largura do pai (320px)
      heightFactor: 0.5,  // 50% da altura do pai (150px)
      child: Container(
        color: Colors.blue,
        child: Center(
          child: Text('80% x 50%'),
        ),
      ),
    ),
  ),
)
```

Este widget é particularmente útil para criar elementos centralizados que mantêm uma proporção consistente em relação ao seu container, independentemente do tamanho absoluto da tela. Um caso de uso comum é criar modais ou dialogs que ocupam uma fração específica da tela.

**Aplicação Prática - Card Responsivo:**

Imagine que você está criando um card de destaque que deve sempre ocupar 90% da largura disponível em mobile, mas não mais que 600 pixels em telas maiores. O FractionallySizedBox combinado com constraints resolve isso elegantemente:

```dart
// Card que adapta sua largura de forma inteligente
class ResponsiveCard extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Center(
      child: ConstrainedBox(
        // Define largura máxima absoluta
        constraints: BoxConstraints(maxWidth: 600),
        child: FractionallySizedBox(
          // 90% da largura disponível, respeitando o máximo de 600px
          widthFactor: 0.9,
          child: Card(
            child: Padding(
              padding: EdgeInsets.all(16),
              child: Column(
                children: [
                  Text('Card Responsivo'),
                  Text('Adapta-se perfeitamente ao dispositivo'),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}
```

Este padrão combina o melhor dos dois mundos: comportamento fluído em telas menores através do FractionallySizedBox, e um limite superior razoável em telas grandes através do ConstrainedBox, evitando que o conteúdo fique excessivamente esticado.

**AspectRatio - Mantendo Proporções Visuais:**

O widget AspectRatio garante que seu filho mantenha uma proporção específica de largura por altura, independentemente do espaço disponível. Isso é fundamental para manter a integridade visual de imagens, vídeos, ou qualquer elemento onde a proporção é crucial para a estética ou funcionalidade.

```dart
// Diferentes proporções comuns
Column(
  children: [
    // Proporção quadrada (1:1)
    AspectRatio(
      aspectRatio: 1.0,  // largura / altura = 1.0
      child: Container(
        color: Colors.red,
        child: Center(child: Text('Quadrado 1:1')),
      ),
    ),
    
    SizedBox(height: 16),
    
    // Proporção widescreen (16:9)
    AspectRatio(
      aspectRatio: 16 / 9,  // 1.777...
      child: Container(
        color: Colors.blue,
        child: Center(child: Text('Widescreen 16:9')),
      ),
    ),
    
    SizedBox(height: 16),
    
    // Proporção retrato (9:16)
    AspectRatio(
      aspectRatio: 9 / 16,  // 0.5625
      child: Container(
        color: Colors.green,
        child: Center(child: Text('Retrato 9:16')),
      ),
    ),
  ],
)
```

**Caso Real - Grid de Imagens Responsivo:**

Um dos usos mais práticos do AspectRatio é em grids de imagens ou produtos, onde você quer que todos os itens mantenham proporções consistentes independentemente do tamanho da tela:

```dart
// Grid de produtos com proporções consistentes
GridView.builder(
  gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
    crossAxisCount: MediaQuery.of(context).size.width > 600 ? 3 : 2,
    crossAxisSpacing: 8,
    mainAxisSpacing: 8,
  ),
  itemBuilder: (context, index) {
    return AspectRatio(
      aspectRatio: 3 / 4,  // Proporção de card de produto típico
      child: Card(
        child: Column(
          children: [
            // Imagem ocupa 70% da altura
            Expanded(
              flex: 7,
              child: Image.network('url', fit: BoxFit.cover),
            ),
            // Informações ocupam 30% da altura
            Expanded(
              flex: 3,
              child: Padding(
                padding: EdgeInsets.all(8),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text('Nome do Produto'),
                    Text('R\$ 99,90'),
                  ],
                ),
              ),
            ),
          ],
        ),
      ),
    );
  },
)
```

Este padrão garante que todos os cards do grid tenham exatamente a mesma proporção, criando uma grade visualmente harmoniosa e profissional, independentemente de estar rodando em um smartphone pequeno ou em um tablet grande.

---

## **SLIDE 9: Comparação Prática - Quando Usar Cada Widget**

Agora que entendemos os widgets individualmente, vamos consolidar esse conhecimento com uma análise comparativa que ajudará você a escolher a ferramenta certa para cada situação específica. A escolha do widget correto não apenas simplifica seu código, mas também torna a manutenção muito mais fácil e o comportamento mais previsível.

**Matriz de Decisão:**

Quando você precisa distribuir espaço entre múltiplos elementos irmãos que estão dentro de uma Row ou Column, e quer que esses elementos cresçam proporcionalmente para preencher o espaço disponível, utilize Expanded com valores de flex apropriados. Este é o caso mais comum em layouts responsivos onde você tem múltiplas seções que precisam compartilhar o espaço disponível de forma proporcional.

Quando você tem um elemento que precisa participar da distribuição de espaço mas tem um tamanho intrínseco que gostaria de respeitar quando possível, utilize Flexible. Um exemplo clássico são botões em uma barra de ações, onde você quer que eles cresçam se houver espaço extra, mas não quer forçá-los a serem maiores que seu conteúdo natural.

Quando você precisa que um único widget tenha um tamanho definido como porcentagem exata de seu pai, e não está preocupado com a distribuição entre irmãos, utilize FractionallySizedBox. Isso é perfeito para criar elementos centralizados ou para implementar designs onde elementos têm tamanhos específicos relativos ao container.

Quando a proporção largura-altura de um elemento é crítica para sua apresentação visual, como imagens, vídeos, ou cards de produtos, sempre utilize AspectRatio. Isso garante que a estética do seu design permaneça consistente em todos os tamanhos de tela.

**Exemplo Integrado - Dashboard Responsivo:**

Vamos ver como todos esses widgets trabalham juntos em um exemplo real de dashboard:

```dart
class ResponsiveDashboard extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // Seção de header com proporção fixa
        AspectRatio(
          aspectRatio: 16 / 3,  // Banner largo
          child: Container(
            color: Colors.blue,
            child: Center(
              child: FractionallySizedBox(
                widthFactor: 0.9,  // Conteúdo ocupa 90% da largura
                child: Text(
                  'Dashboard Principal',
                  style: TextStyle(fontSize: 24, color: Colors.white),
                ),
              ),
            ),
          ),
        ),
        
        // Área de conteúdo expansível (ocupa espaço restante)
        Expanded(
          child: Row(
            children: [
              // Sidebar - 25% do espaço horizontal
              Expanded(
                flex: 1,
                child: Container(
                  color: Colors.grey[200],
                  child: Center(child: Text('Sidebar')),
                ),
              ),
              
              // Conteúdo principal - 75% do espaço horizontal
              Expanded(
                flex: 3,
                child: GridView.count(
                  crossAxisCount: 2,
                  children: List.generate(
                    4,
                    (index) => AspectRatio(
                      aspectRatio: 1.0,  // Cards quadrados
                      child: Card(
                        margin: EdgeInsets.all(8),
                        child: Center(child: Text('Card $index')),
                      ),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ),
        
        // Footer com botões flexíveis
        Container(
          padding: EdgeInsets.all(8),
          color: Colors.grey[300],
          child: Row(
            children: [
              // Botões que crescem se houver espaço, mas respeitam tamanho mínimo
              Flexible(
                child: ElevatedButton(
                  onPressed: () {},
                  child: Text('Ação 1'),
                ),
              ),
              SizedBox(width: 8),
              Flexible(
                child: ElevatedButton(
                  onPressed: () {},
                  child: Text('Ação 2'),
                ),
              ),
              SizedBox(width: 8),
              Flexible(
                child: ElevatedButton(
                  onPressed: () {},
                  child: Text('Ação Principal Mais Longa'),
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }
}
```

**Antipadrões - O Que Evitar:**

Um erro comum é tentar usar Expanded ou Flexible fora de um Row, Column ou Flex. Estes widgets dependem da presença de um pai específico que implementa o protocolo de distribuição de espaço, e não funcionarão corretamente em outros contextos.

Outro equívoco frequente é combinar valores de flex extremamente desproporcionais, como flex: 1 e flex: 100. Embora tecnicamente funcione, isso torna o código difícil de manter e raciocinar. Mantenha os valores de flex em escalas razoáveis, tipicamente entre 1 e 10.

Evite também usar FractionallySizedBox com valores maiores que 1.0, pois isso causará overflow. Se você precisa que um elemento seja maior que seu pai, considere usar OverflowBox ou repensar a estrutura do layout.

---

## ✅ CHECKPOINT 3

Concluímos o Módulo 3 cobrindo os widgets fundamentais para layouts responsivos com explicações detalhadas e exemplos práticos integrados. O próximo módulo abordará a arquitetura e organização do código para projetos responsivos em escala profissional.

Posso prosseguir para o Módulo 4 sobre Arquitetura e Organização?