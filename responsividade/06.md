# MÓDULO 5: IMPLEMENTAÇÃO PRÁTICA - MONTANDO OS LAYOUTS (CONTINUAÇÃO)

## **SLIDE 15: Implementação Mobile - Layout Vertical Otimizado**

Agora que temos nossos componentes base prontos, vamos começar a montá-los em layouts específicos para cada tipo de dispositivo. Começaremos com o layout mobile, que é o mais restritivo e, portanto, nos força a pensar cuidadosamente sobre priorização de informações. Este conceito de começar pelo mobile é conhecido como mobile-first design, uma abordagem que tem se provado extremamente eficaz no desenvolvimento responsivo porque garante que a experiência funcione bem mesmo nas condições mais limitadas.

O desafio fundamental do layout mobile é que temos muito pouca largura disponível, tipicamente entre 320 e 428 pixels lógicos dependendo do dispositivo. Isso significa que não podemos colocar elementos lado a lado como faríamos em telas maiores. Em vez disso, precisamos adotar uma abordagem vertical onde cada elemento ocupa a largura total disponível e os usuários fazem scroll vertical para acessar mais conteúdo. Esta é uma interação natural em dispositivos móveis, onde os usuários estão acostumados a rolar com o polegar.

Vamos implementar nosso dashboard mobile de forma que as informações mais críticas apareçam primeiro, sem necessidade de scroll. Imagine nosso vendedor em campo que abre o aplicativo rapidamente entre reuniões de cliente. Ele quer ver imediatamente suas vendas do dia e quanto falta para sua meta. Somente se ele tiver tempo adicional é que vai rolar para ver gráficos detalhados ou rankings completos.

```dart
// lib/screens/dashboard/mobile_dashboard.dart

import 'package:flutter/material.dart';
import '../../core/responsive/responsive_values.dart';
import '../../widgets/dashboard/metric_card.dart';
import '../../widgets/dashboard/chart_card.dart';
import '../../widgets/dashboard/top_sellers_list.dart';
import '../../models/dashboard_data.dart';

/// Implementação mobile do dashboard.
/// Layout vertical com scroll, priorizando métricas principais no topo.
class MobileDashboard extends StatelessWidget {
  const MobileDashboard({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Dashboard de Vendas'),
        elevation: 2,
        actions: [
          // Botão de filtro que poderia abrir um bottom sheet
          IconButton(
            icon: const Icon(Icons.filter_list),
            onPressed: () {
              // TODO: Implementar filtros
            },
          ),
        ],
      ),
      body: RefreshIndicator(
        // Permite pull-to-refresh, padrão esperado em mobile
        onRefresh: () async {
          // TODO: Implementar refresh de dados
          await Future.delayed(const Duration(seconds: 1));
        },
        child: ListView(
          // Padding adaptativo nas laterais
          padding: EdgeInsets.symmetric(
            horizontal: ResponsiveValues.getHorizontalPadding(context),
            vertical: ResponsiveValues.getVerticalPadding(context),
          ),
          children: [
            // Seção de métricas principais (sempre visível sem scroll)
            _buildMetricsSection(context),
            
            SizedBox(height: ResponsiveValues.getSectionSpacing(context)),
            
            // Gráfico de vendas da semana
            _buildWeeklySalesChart(context),
            
            SizedBox(height: ResponsiveValues.getSectionSpacing(context)),
            
            // Top 3 vendedores (versão compacta para mobile)
            _buildTopSellersSection(context),
            
            SizedBox(height: ResponsiveValues.getSectionSpacing(context)),
            
            // Card de ações rápidas
            _buildQuickActionsCard(context),
            
            // Espaço extra no final para conforto visual
            SizedBox(height: ResponsiveValues.getVerticalPadding(context)),
          ],
        ),
      ),
      // Floating action button para ação primária (nova venda)
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          // TODO: Navegar para tela de nova venda
        },
        icon: const Icon(Icons.add),
        label: const Text('Nova Venda'),
      ),
    );
  }
  
  /// Constrói a seção de métricas principais
  /// Em mobile, empilhamos verticalmente para maximizar legibilidade
  Widget _buildMetricsSection(BuildContext context) {
    // Dados mockados - em produção viriam de um provider ou bloc
    final metrics = [
      MetricData(
        title: 'Vendas Hoje',
        value: 12500,
        previousValue: 10800,
        unit: 'R\$ ',
        icon: Icons.trending_up,
      ),
      MetricData(
        title: 'Meta do Mês',
        value: 85,
        previousValue: 72,
        unit: '',
        icon: Icons.flag,
      ),
      MetricData(
        title: 'Novos Clientes',
        value: 23,
        previousValue: 18,
        unit: '',
        icon: Icons.person_add,
      ),
    ];
    
    return Column(
      children: metrics.map((metric) {
        return Padding(
          padding: EdgeInsets.only(
            bottom: ResponsiveValues.getElementSpacing(context),
          ),
          child: MetricCard(data: metric),
        );
      }).toList(),
    );
  }
  
  /// Constrói o gráfico de vendas semanais
  /// Em mobile, usamos altura fixa generosa para boa visualização
  Widget _buildWeeklySalesChart(BuildContext context) {
    // Dados mockados da semana
    final chartData = [
      ChartData('Seg', 1200),
      ChartData('Ter', 1800),
      ChartData('Qua', 1500),
      ChartData('Qui', 2100),
      ChartData('Sex', 1900),
      ChartData('Sáb', 800),
      ChartData('Dom', 600),
    ];
    
    return SizedBox(
      // Altura fixa adequada para visualização confortável em mobile
      height: 250,
      child: ChartCard(
        title: 'Vendas da Semana',
        data: chartData,
      ),
    );
  }
  
  /// Constrói a seção de top vendedores
  /// Em mobile, mostramos apenas top 3 para economizar espaço
  Widget _buildTopSellersSection(BuildContext context) {
    final sellers = [
      SellerData(name: 'João Silva', sales: 45000, position: 1),
      SellerData(name: 'Maria Santos', sales: 42000, position: 2),
      SellerData(name: 'Pedro Oliveira', sales: 38000, position: 3),
      SellerData(name: 'Ana Costa', sales: 35000, position: 4),
      SellerData(name: 'Carlos Souza', sales: 32000, position: 5),
    ];
    
    return TopSellersList(
      sellers: sellers,
      maxItems: 3,  // Apenas top 3 em mobile
    );
  }
  
  /// Card com ações rápidas que o usuário pode precisar
  /// Exemplo de como podemos adicionar funcionalidades específicas para mobile
  Widget _buildQuickActionsCard(BuildContext context) {
    return Card(
      elevation: 2,
      child: Padding(
        padding: EdgeInsets.all(
          ResponsiveValues.getHorizontalPadding(context),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Ações Rápidas',
              style: TextStyle(
                fontSize: ResponsiveValues.getSubtitleFontSize(context),
                fontWeight: FontWeight.bold,
              ),
            ),
            SizedBox(height: ResponsiveValues.getElementSpacing(context)),
            
            // Botões de ação em layout vertical para mobile
            _buildActionButton(
              context,
              icon: Icons.receipt_long,
              label: 'Ver Relatórios',
              onTap: () {},
            ),
            SizedBox(height: ResponsiveValues.getElementSpacing(context) / 2),
            _buildActionButton(
              context,
              icon: Icons.share,
              label: 'Compartilhar Resultados',
              onTap: () {},
            ),
            SizedBox(height: ResponsiveValues.getElementSpacing(context) / 2),
            _buildActionButton(
              context,
              icon: Icons.settings,
              label: 'Configurações',
              onTap: () {},
            ),
          ],
        ),
      ),
    );
  }
  
  /// Helper para criar botões de ação consistentes
  Widget _buildActionButton(
    BuildContext context, {
    required IconData icon,
    required String label,
    required VoidCallback onTap,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        padding: EdgeInsets.symmetric(
          horizontal: ResponsiveValues.getHorizontalPadding(context),
          vertical: ResponsiveValues.getElementSpacing(context),
        ),
        decoration: BoxDecoration(
          border: Border.all(color: Colors.grey[300]!),
          borderRadius: BorderRadius.circular(8),
        ),
        child: Row(
          children: [
            Icon(icon, size: 20, color: Theme.of(context).primaryColor),
            SizedBox(width: ResponsiveValues.getElementSpacing(context)),
            Expanded(
              child: Text(
                label,
                style: TextStyle(
                  fontSize: ResponsiveValues.getBodyFontSize(context),
                  fontWeight: FontWeight.w500,
                ),
              ),
            ),
            Icon(Icons.chevron_right, size: 20, color: Colors.grey),
          ],
        ),
      ),
    );
  }
}
```

Esta implementação mobile demonstra vários conceitos importantes. Primeiro, observe como usamos RefreshIndicator, que é um padrão esperado em aplicações mobile onde usuários frequentemente puxam para baixo para atualizar dados. Segundo, note como incluímos apenas o top três vendedores em vez de cinco ou mais, reconhecendo que espaço de tela é precioso em mobile e o usuário pode sempre navegar para uma tela dedicada se quiser ver o ranking completo. Terceiro, adicionamos um FloatingActionButton para a ação mais importante, que é registrar uma nova venda, tornando-a sempre acessível sem scroll.

A seção de ações rápidas no final é um bom exemplo de como pensar em mobile-first. Em dispositivos móveis, usuários frequentemente querem completar tarefas específicas rapidamente, então fornecemos atalhos diretos para as ações mais comuns. Cada botão de ação usa InkWell para fornecer feedback tátil apropriado quando tocado, que é uma expectativa fundamental em interfaces mobile.

---

## **SLIDE 16: Implementação Tablet - Layout de Duas Colunas**

Quando migramos de mobile para tablet, nosso espaço horizontal disponível tipicamente dobra ou até triplica. Isso nos permite repensar fundamentalmente como organizamos a informação. Em vez de uma única coluna vertical, podemos começar a usar layouts de duas colunas que permitem ao usuário ver mais informações simultaneamente sem necessidade de scroll constante. Este é um salto significativo em termos de densidade de informação e capacidade de análise.

O cenário de uso típico de um tablet é diferente do mobile. Enquanto no mobile imaginamos um vendedor em pé, rapidamente checando métricas entre reuniões, no tablet imaginamos um gerente sentado em uma sala de conferência, talvez com o tablet na mesa, analisando o desempenho da equipe em mais detalhe. Este usuário tem mais tempo e atenção para dedicar à análise, então podemos e devemos fornecer visualizações mais ricas.

Nossa estratégia para tablet será dividir a tela em uma coluna principal (aproximadamente setenta por cento da largura) que mostrará gráficos e métricas em um grid de duas colunas, e uma barra lateral (aproximadamente trinta por cento) que mostrará o ranking completo de vendedores e eventuais filtros. Esta divisão permite que o usuário mantenha o contexto do ranking enquanto explora diferentes visualizações na área principal.

```dart
// lib/screens/dashboard/tablet_dashboard.dart

import 'package:flutter/material.dart';
import '../../core/responsive/responsive_values.dart';
import '../../widgets/dashboard/metric_card.dart';
import '../../widgets/dashboard/chart_card.dart';
import '../../widgets/dashboard/top_sellers_list.dart';
import '../../models/dashboard_data.dart';

/// Implementação tablet do dashboard.
/// Layout de duas colunas: área principal e sidebar.
class TabletDashboard extends StatelessWidget {
  const TabletDashboard({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Dashboard de Vendas'),
        elevation: 2,
        actions: [
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: () {
              // TODO: Refresh dados
            },
          ),
          IconButton(
            icon: const Icon(Icons.filter_list),
            onPressed: () {
              // TODO: Mostrar filtros
            },
          ),
        ],
      ),
      body: Row(
        children: [
          // Área principal (70% da largura)
          Expanded(
            flex: 7,
            child: _buildMainContent(context),
          ),
          
          // Divider visual entre as colunas
          const VerticalDivider(width: 1, thickness: 1),
          
          // Sidebar direita (30% da largura)
          Expanded(
            flex: 3,
            child: _buildSidebar(context),
          ),
        ],
      ),
    );
  }
  
  /// Constrói o conteúdo principal com scroll
  /// Inclui métricas em grid e gráficos
  Widget _buildMainContent(BuildContext context) {
    return ListView(
      padding: EdgeInsets.all(
        ResponsiveValues.getHorizontalPadding(context),
      ),
      children: [
        // Grid de métricas (2 colunas em tablet)
        _buildMetricsGrid(context),
        
        SizedBox(height: ResponsiveValues.getSectionSpacing(context)),
        
        // Gráfico principal ocupando largura total
        _buildMainChart(context),
        
        SizedBox(height: ResponsiveValues.getSectionSpacing(context)),
        
        // Segundo gráfico (vendas por categoria, por exemplo)
        _buildCategoryChart(context),
      ],
    );
  }
  
  /// Grid de métricas em 2 colunas
  /// Aproveita largura adicional do tablet
  Widget _buildMetricsGrid(BuildContext context) {
    final metrics = [
      MetricData(
        title: 'Vendas Hoje',
        value: 12500,
        previousValue: 10800,
        unit: 'R\$ ',
        icon: Icons.trending_up,
      ),
      MetricData(
        title: 'Meta do Mês',
        value: 85,
        previousValue: 72,
        unit: '%',
        icon: Icons.flag,
      ),
      MetricData(
        title: 'Novos Clientes',
        value: 23,
        previousValue: 18,
        unit: '',
        icon: Icons.person_add,
      ),
      MetricData(
        title: 'Ticket Médio',
        value: 542,
        previousValue: 488,
        unit: 'R\$ ',
        icon: Icons.receipt,
      ),
    ];
    
    // Em tablet, usamos GridView para layout de 2 colunas
    // Calculamos altura baseado no número de linhas necessárias
    final rows = (metrics.length / 2).ceil();
    final cardHeight = 120.0;
    final spacing = ResponsiveValues.getElementSpacing(context);
    final totalHeight = (rows * cardHeight) + ((rows - 1) * spacing);
    
    return SizedBox(
      height: totalHeight,
      child: GridView.builder(
        // Desabilita scroll do grid (scroll é gerenciado pelo ListView pai)
        physics: const NeverScrollableScrollPhysics(),
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: 2,
          crossAxisSpacing: spacing,
          mainAxisSpacing: spacing,
          childAspectRatio: 2.5,  // Proporção largura/altura dos cards
        ),
        itemCount: metrics.length,
        itemBuilder: (context, index) {
          return MetricCard(data: metrics[index]);
        },
      ),
    );
  }
  
  /// Gráfico principal de vendas semanais
  Widget _buildMainChart(BuildContext context) {
    final chartData = [
      ChartData('Seg', 1200),
      ChartData('Ter', 1800),
      ChartData('Qua', 1500),
      ChartData('Qui', 2100),
      ChartData('Sex', 1900),
      ChartData('Sáb', 800),
      ChartData('Dom', 600),
    ];
    
    return SizedBox(
      height: 300,  // Altura maior que mobile para melhor visualização
      child: ChartCard(
        title: 'Vendas da Semana',
        data: chartData,
      ),
    );
  }
  
  /// Gráfico secundário (vendas por categoria)
  Widget _buildCategoryChart(BuildContext context) {
    final categoryData = [
      ChartData('Eletrônicos', 4500),
      ChartData('Vestuário', 3200),
      ChartData('Alimentos', 2800),
      ChartData('Livros', 1500),
    ];
    
    return SizedBox(
      height: 250,
      child: ChartCard(
        title: 'Vendas por Categoria',
        data: categoryData,
        barColor: Colors.teal,
      ),
    );
  }
  
  /// Sidebar com informações complementares
  /// Permanece visível enquanto usuário navega pelo conteúdo principal
  Widget _buildSidebar(BuildContext context) {
    return ListView(
      padding: EdgeInsets.all(
        ResponsiveValues.getHorizontalPadding(context),
      ),
      children: [
        // Título da seção
        Text(
          'Rankings',
          style: TextStyle(
            fontSize: ResponsiveValues.getSubtitleFontSize(context),
            fontWeight: FontWeight.bold,
          ),
        ),
        
        SizedBox(height: ResponsiveValues.getElementSpacing(context)),
        
        // Lista completa de top vendedores (5 itens em tablet)
        _buildTopSellers(context),
        
        SizedBox(height: ResponsiveValues.getSectionSpacing(context)),
        
        // Card adicional com meta da equipe
        _buildTeamGoalCard(context),
      ],
    );
  }
  
  Widget _buildTopSellers(BuildContext context) {
    final sellers = [
      SellerData(name: 'João Silva', sales: 45000, position: 1),
      SellerData(name: 'Maria Santos', sales: 42000, position: 2),
      SellerData(name: 'Pedro Oliveira', sales: 38000, position: 3),
      SellerData(name: 'Ana Costa', sales: 35000, position: 4),
      SellerData(name: 'Carlos Souza', sales: 32000, position: 5),
    ];
    
    return TopSellersList(
      sellers: sellers,
      maxItems: 5,  // Top 5 completo em tablet
    );
  }
  
  /// Card mostrando progresso da meta da equipe
  Widget _buildTeamGoalCard(BuildContext context) {
    const currentValue = 285000.0;
    const goalValue = 350000.0;
    final progress = currentValue / goalValue;
    
    return Card(
      elevation: 2,
      color: Colors.blue[50],
      child: Padding(
        padding: EdgeInsets.all(
          ResponsiveValues.getHorizontalPadding(context),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Meta da Equipe',
              style: TextStyle(
                fontSize: ResponsiveValues.getSubtitleFontSize(context),
                fontWeight: FontWeight.bold,
              ),
            ),
            SizedBox(height: ResponsiveValues.getElementSpacing(context)),
            
            // Barra de progresso
            ClipRRect(
              borderRadius: BorderRadius.circular(8),
              child: LinearProgressIndicator(
                value: progress,
                minHeight: 12,
                backgroundColor: Colors.grey[300],
                valueColor: AlwaysStoppedAnimation<Color>(
                  Colors.blue[700]!,
                ),
              ),
            ),
            
            SizedBox(height: ResponsiveValues.getElementSpacing(context)),
            
            // Valores
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  'R\$ ${(currentValue / 1000).toStringAsFixed(0)}K',
                  style: TextStyle(
                    fontSize: ResponsiveValues.getBodyFontSize(context),
                    fontWeight: FontWeight.bold,
                    color: Colors.blue[700],
                  ),
                ),
                Text(
                  'Meta: R\$ ${(goalValue / 1000).toStringAsFixed(0)}K',
                  style: TextStyle(
                    fontSize: ResponsiveValues.getBodyFontSize(context) * 0.9,
                    color: Colors.grey[600],
                  ),
                ),
              ],
            ),
            
            SizedBox(height: ResponsiveValues.getElementSpacing(context) / 2),
            
            Text(
              '${(progress * 100).toStringAsFixed(0)}% concluído',
              style: TextStyle(
                fontSize: ResponsiveValues.getBodyFontSize(context) * 0.85,
                color: Colors.grey[600],
              ),
            ),
          ],
        ),
      ),
    );
  }
}
```

A implementação tablet demonstra como podemos começar a adicionar complexidade visual e densidade de informação conforme o espaço disponível aumenta. O grid de métricas em duas colunas permite que o usuário veja quatro métricas importantes simultaneamente, sem scroll. A sidebar fixa mantém o ranking de vendedores sempre visível, fornecendo contexto contínuo enquanto o usuário explora os gráficos na área principal.

Note também a adição do card de meta da equipe na sidebar. Este é um exemplo de como podemos adicionar elementos informativos extras em layouts maiores sem sobrecarregar a interface. Em mobile, este card provavelmente seria omitido ou movido para uma tela separada, mas em tablet temos espaço suficiente para incluí-lo de forma que agregue valor sem causar distração.

O uso de Expanded com flex 7 e 3 cria uma divisão setenta/trinta que se provou eficaz em muitos dashboards profissionais, mantendo a área principal de análise como foco primário enquanto a sidebar fornece informações de suporte.

---

## ✅ CHECKPOINT 6

Concluímos as implementações de mobile e tablet do nosso dashboard. Vimos como os mesmos componentes base podem ser reorganizados de formas radicalmente diferentes para otimizar a experiência em cada tipo de dispositivo. No próximo e último slide deste módulo, implementaremos a versão desktop com layout de três colunas e funcionalidades ainda mais avançadas. Posso continuar?